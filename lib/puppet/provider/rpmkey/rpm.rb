require 'rexml/document'
include REXML

Puppet::Type.type(:rpmkey).provide(:rpm) do
  commands :rpm => 'rpm'

  mk_resource_methods

  def self.instances
    begin
      rpm_query = rpm('-q', 'gpg-pubkey', '--xml')
    rescue Puppet::ExecutionFailure
      return []
    end

    # the xml format generated by rpm is missing enclosing tags
    output = '<rpm>' << rpm_query << '</rpm>'

    keys = parse_rpm_query(output)
    keys.collect do |key|
      key[:ensure] = :present
      new(key)
    end
  end

  def self.prefetch(resources)
    instances.each do |prov|
      if resource = resources[prov.name]
        resource.provider = prov
      end
    end
  end

  def create
    raise Puppet::Error, "Cannot add key without a source" unless @resource[:source]
    rpm('--import', @resource[:source])
  end

  def exists?
    get(:ensure) != :absent
  end

  def destroy
    rpm('-e', '--allmatches', package)
  end

  self.resource_type.validproperties.each do |prop|
    next if prop == :ensure
    define_method("#{prop}=".to_sym) do |x|
      raise Puppet::Error, "#{prop} is read-only"
    end
  end

  private

  @xml_properties = {
    'Name'        => 'string',
    'Version'     => 'string',
    'Release'     => 'string',
    'Installtime' => 'integer',
    'Buildtime'   => 'integer',
    'Packager'    => 'string',
    'Sha1header'  => 'string',
  }

  # reconstruct pedantic package name from rpm info
  def self.package_name(rpm_info)
    "#{rpm_info['Name']}-#{rpm_info['Version']}-#{rpm_info['Release']}"
  end

  # convert unix epoch timestamp into `date(1)` format to match watch is output
  # by `rpm -qi <package>`
  def self.ts_to_date(unix)
    Time.at(unix).strftime("%a %b %e %H:%M:%S %Z %Y")
  end

  def self.validate_rpm_info(rpm_info)
    @xml_properties.keys.each do |prop|
      unless rpm_info.has_key?(prop) and not rpm_info[prop].nil?
        warning "Unexpected rpm output: #{prop} property is undefined."
        return false
      end
    end

    true
  end

  def self.mangle_rpm_info(rpm_info)
    {
      :name         => rpm_info['Version'].upcase,
      :install_date => ts_to_date(rpm_info['Installtime']),
      :build_date   => ts_to_date(rpm_info['Buildtime']),
      :packager     => rpm_info['Packager'],
      :package      => package_name(rpm_info),
    }
  end

  def self.parse_rpm_query(output)
    doc = REXML::Document.new output

    pkgs = XPath.match( doc, "/rpm/rpmHeader" )
    info = pkgs.collect do |rpm|
      rpm_info = {}
      @xml_properties.each do |k,v|
        value = XPath.first(rpm, "rpmTag[@name = '#{k}']/#{v}")
        next if value.nil?
        if v == 'integer'
          rpm_info[k] = value.text.to_i
        else
          rpm_info[k] = value.text
        end
      end
      rpm_info
    end

    info.reject! {|x| validate_rpm_info(x) != true }
    info.collect {|x| mangle_rpm_info(x) }
  end
end
